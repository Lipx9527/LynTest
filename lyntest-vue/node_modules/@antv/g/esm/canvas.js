import { __assign, __extends } from "tslib";
import * as Util from '@antv/util';
import * as renderers from './renderers/index';
import Event from './event';
import Timeline from './core/timeline';
import Group from './core/group';
var EVENTS = [
    'click',
    'mousedown',
    'mouseup',
    'dblclick',
    'contextmenu',
    'mouseenter',
    'mouseleave',
    'mouseover',
    'mouseout',
    'mousemove',
    'wheel',
];
var preShape = null;
var mousedown = null;
var dragging = null;
function toNumber(value) {
    return +value;
}
var Canvas = /** @class */ (function (_super) {
    __extends(Canvas, _super);
    function Canvas(cfg) {
        var _this = _super.call(this, __assign({ eventEnable: true, 
            /**
             * 像素宽度
             * @type {Number}
             */
            width: null, 
            /**
             * 像素高度
             * @type {Number}
             */
            height: null, 
            /**
             * 画布宽度
             * @type {Number}
             */
            widthCanvas: null, 
            /**
             * 画布高度
             * @type {Number}
             */
            heightCanvas: null, 
            /**
             * CSS宽
             * @type {String}
             */
            widthStyle: null, 
            /**
             * CSS高
             * @type {String}
             */
            heightStyle: null, 
            /**
             * 容器DOM
             * @type {Object}
             */
            containerDOM: null, 
            /**
             * 当前Canvas的DOM
             * @type {Object}
             */
            canvasDOM: null, 
            /**
             * 屏幕像素比
             * @type {Number}
             */
            pixelRatio: null, 
            /**
             * 渲染器，默认是canvas
             * @type {String}
             */
            renderer: 'canvas' }, cfg)) || this;
        _this._setGlobalParam();
        _this._setContainer();
        _this._initPainter();
        _this._scale();
        if (_this.get('eventEnable')) {
            _this.registerEvent();
        }
        return _this;
    }
    Canvas.prototype._scale = function () {
        if (this.cfg.renderType !== 'svg') {
            var pixelRatio = this.get('pixelRatio');
            this.scale(pixelRatio, pixelRatio);
        }
    };
    Canvas.prototype._setGlobalParam = function () {
        var renderType = this.get('renderer') || 'canvas';
        if (renderType === 'svg') {
            this.set('pixelRatio', 1);
        }
        else if (!this.get('pixelRatio')) {
            this.set('pixelRatio', Util.getRatio());
        }
        this.cfg.renderType = renderType;
        var renderer = renderers[renderType];
        this.cfg.renderer = renderer;
        this.cfg.canvas = this;
        var timeline = new Timeline(this);
        this.cfg.timeline = timeline;
    };
    Canvas.prototype._setContainer = function () {
        var containerId = this.get('containerId');
        var containerDOM = this.get('containerDOM');
        if (!containerDOM) {
            containerDOM = document.getElementById(containerId);
            this.set('containerDOM', containerDOM);
        }
        Util.modifyCSS(containerDOM, {
            position: 'relative',
        });
        var transformString = containerDOM.style.transform;
        var cssTransform = [];
        var regex = /(\w+)\((.+?)\)/g;
        var match = regex.exec(transformString);
        while (match) {
            cssTransform.push([match[1], match[2].split(', ')]);
            match = regex.exec(transformString);
        }
        // 当前仅对 scale transform 进行处理
        var containerTransform = {
            scaleX: 1,
            scaleY: 1
        };
        Util.each(cssTransform, function (item, key) {
            // transform 方法名
            var method = item[0];
            // 第一个参数值
            var param1 = item[1] && item[1][0];
            // 第二个参数值
            var param2 = item[1] && item[1][1];
            if (method === 'scale') {
                containerTransform.scaleX = Util.isNil(param1) ? 1 : toNumber(param1);
                // 对于 scale，第二个参数值为空时，等价于第一个参数值
                containerTransform.scaleY = Util.isNil(param2) ? containerTransform.scaleX : toNumber(param2);
            }
            else if (method === key) {
                containerTransform[key] = param1;
            }
        });
        this.set('containerTransform', containerTransform);
    };
    Canvas.prototype._initPainter = function () {
        var containerDOM = this.get('containerDOM');
        var painter = new this.cfg.renderer.painter(containerDOM);
        this.cfg.painter = painter;
        this.cfg.canvasDOM = this.cfg.el = painter.canvas;
        this.changeSize(this.get('width'), this.get('height'));
    };
    Canvas.prototype._resize = function () {
        var canvasDOM = this.get('canvasDOM');
        var widthCanvas = this.get('widthCanvas');
        var heightCanvas = this.get('heightCanvas');
        var widthStyle = this.get('widthStyle');
        var heightStyle = this.get('heightStyle');
        canvasDOM.style.width = widthStyle;
        canvasDOM.style.height = heightStyle;
        canvasDOM.setAttribute('width', widthCanvas);
        canvasDOM.setAttribute('height', heightCanvas);
    };
    Canvas.prototype.getWidth = function () {
        var pixelRatio = this.get('pixelRatio');
        var width = this.get('width');
        return width * pixelRatio;
    };
    Canvas.prototype.getHeight = function () {
        var pixelRatio = this.get('pixelRatio');
        var height = this.get('height');
        return height * pixelRatio;
    };
    Canvas.prototype.changeSize = function (width, height) {
        var pixelRatio = this.get('pixelRatio');
        var widthCanvas = width * pixelRatio;
        var heightCanvas = height * pixelRatio;
        this.set('widthCanvas', widthCanvas);
        this.set('heightCanvas', heightCanvas);
        this.set('widthStyle', width + 'px');
        this.set('heightStyle', height + 'px');
        this.set('width', width);
        this.set('height', height);
        this._resize();
    };
    /**
     * 将窗口坐标转变成 canvas 坐标
     * @param  {Number} clientX 窗口x坐标
     * @param  {Number} clientY 窗口y坐标
     * @return {Object} canvas坐标
     */
    Canvas.prototype.getPointByClient = function (clientX, clientY) {
        var containerTransform = this.get('containerTransform');
        var scaleX = containerTransform.scaleX, scaleY = containerTransform.scaleY;
        var el = this.get('el');
        var pixelRatio = this.get('pixelRatio') || 1;
        var bbox = el.getBoundingClientRect();
        return {
            x: (clientX - bbox.left) * pixelRatio / scaleX,
            y: (clientY - bbox.top) * pixelRatio / scaleY,
        };
    };
    Canvas.prototype.getClientByPoint = function (x, y) {
        var containerTransform = this.get('containerTransform');
        var scaleX = containerTransform.scaleX, scaleY = containerTransform.scaleY;
        var el = this.get('el');
        var bbox = el.getBoundingClientRect();
        var pixelRatio = this.get('pixelRatio') || 1;
        return {
            clientX: x / pixelRatio * scaleX + bbox.left,
            clientY: y / pixelRatio * scaleY + bbox.top,
        };
    };
    Canvas.prototype.draw = function () {
        this.cfg.painter.draw(this);
    };
    Canvas.prototype.getShape = function (x, y, e) {
        if (arguments.length === 3 && this.cfg.renderer.getShape) {
            return this.cfg.renderer.getShape.call(this, x, y, e);
        }
        return _super.prototype.getShape.call(this, x, y);
    };
    Canvas.prototype.getRenderer = function () {
        return this.cfg.renderType;
    };
    Canvas.prototype._drawSync = function () {
        this.cfg.painter.drawSync(this);
    };
    Canvas.prototype.destroy = function () {
        var cfg = this.cfg;
        var containerDOM = cfg.containerDOM;
        var canvasDOM = cfg.canvasDOM;
        if (canvasDOM && containerDOM) {
            containerDOM.removeChild(canvasDOM);
        }
        cfg.timeline.stop();
        _super.prototype.destroy.call(this);
    };
    Canvas.prototype.registerEvent = function () {
        var self = this;
        var el = this.get('el');
        Util.each(EVENTS, function (evt) {
            el.addEventListener(evt, function (e) {
                self._triggerEvent(evt, e);
            }, false);
        });
        // special cases
        el.addEventListener('touchstart', function (e) {
            if (!Util.isEmpty(e.targetTouches)) {
                self._triggerEvent('touchstart', e);
            }
        }, false);
        el.addEventListener('touchmove', function (e) {
            if (!Util.isEmpty(e.targetTouches)) {
                self._triggerEvent('touchmove', e);
            }
        }, false);
        el.addEventListener('touchend', function (e) {
            if (!Util.isEmpty(e.changedTouches)) {
                self._triggerEvent('touchend', e);
            }
        }, false);
    };
    Canvas.prototype._getEmitter = function (element, event) {
        if (element) {
            if (Util.isEmpty(element.getEvents())) {
                var parent_1 = element.get('parent');
                if (parent_1 && !event.propagationStopped) {
                    return this._getEmitter(parent_1, event);
                }
            }
            else {
                return element;
            }
        }
    };
    Canvas.prototype._getEventObj = function (type, e, point, target) {
        var event = new Event(type, e, true, true);
        event.x = point.x;
        event.y = point.y;
        event.clientX = e.clientX;
        event.clientY = e.clientY;
        event.target = target;
        event.currentTarget = this._getEmitter(target, event);
        return event;
    };
    Canvas.prototype._getClientXY = function (type, e) {
        if (type === 'touchstart' || type === 'touchmove') {
            return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];
        }
        if (type === 'touchend') {
            return [e.changedTouches[0].clientX, e.changedTouches[0].clientY];
        }
        return [e.clientX, e.clientY];
    };
    Canvas.prototype._triggerEvent = function (type, e) {
        var _a = this._getClientXY(type, e), clientX = _a[0], clientY = _a[1];
        var point = this.getPointByClient(clientX, clientY);
        var shape = this.getShape(point.x, point.y, e);
        var el = this.get('el');
        // svg原生事件取不到dragover, dragout, drop等事件的对象。这边需要走数学拾取。
        if (dragging && this.getRenderer() === 'svg') {
            shape = this.getShape(point.x, point.y);
        }
        if (type === 'mousemove') {
            if (preShape && preShape !== shape) {
                this._emitEvent('mouseout', e, point, preShape);
                this._emitEvent('mouseleave', e, point, preShape);
                if (dragging) {
                    this._emitEvent('dragleave', e, point, preShape);
                }
                if (!preShape.destroyed && !preShape.removed) {
                    el.style.cursor = preShape.attr('cursor') || 'default';
                }
            }
            if (dragging) {
                this._emitEvent('drag', e, point, dragging);
                this._emitEvent('mousemove', e, point, shape || this);
            }
            if (shape) {
                if (!dragging) {
                    if (mousedown === shape) {
                        dragging = shape;
                        mousedown = null;
                        this._emitEvent('dragstart', e, point, shape);
                    }
                    else {
                        this._emitEvent('mousemove', e, point, shape);
                    }
                }
                if (preShape !== shape) {
                    this._emitEvent('mouseenter', e, point, shape);
                    this._emitEvent('mouseover', e, point, shape);
                    if (dragging) {
                        this._emitEvent('dragenter', e, point, shape);
                    }
                }
            }
            else {
                var canvasmousemove = this._getEventObj('mousemove', e, point, this);
                this.emit('mousemove', canvasmousemove);
            }
            preShape = shape;
        }
        else {
            this._emitEvent(type, e, point, shape || this);
            if (!dragging && type === 'mousedown') {
                mousedown = shape;
            }
            if (type === 'mouseup') {
                mousedown = null;
                if (dragging) {
                    dragging.cfg.capture = true;
                    this._emitEvent('dragend', e, point, dragging);
                    dragging = null;
                    this._emitEvent('drop', e, point, shape || this);
                }
            }
        }
        if (shape && !shape.destroyed) {
            el.style.cursor = shape.attr('cursor') || 'default';
        }
    };
    Canvas.prototype._emitEvent = function (type, evt, point, shape) {
        var event = this._getEventObj(type, evt, point, shape);
        var emitShape = this._getEmitter(shape, evt);
        emitShape && emitShape.emit(type, event);
        return emitShape;
    };
    return Canvas;
}(Group));
export default Canvas;
//# sourceMappingURL=canvas.js.map